[ { "title": "无语", "url": "/posts/%E6%97%A0%E8%AF%AD/", "categories": "", "tags": "", "date": "2022-04-24 00:00:00 +0000", "snippet": "…感觉连C++语言还不怎么会呢，还要挣扎着学数据结构猪脑过载" }, { "title": "树的学习笔记", "url": "/posts/%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/", "categories": "", "tags": "", "date": "2022-04-21 00:00:00 +0000", "snippet": "二叉树基本概念1.记录根节点的高度为0，那么一个满二叉树的结点个数为2^(h+1)-1利用等比求和…..，最少为h+1二叉树的实现1.基本结点BinNode 模板类#define BinNodePosi(T) BinNode&amp;lt;T&amp;gt;* //结点位置template &amp;lt;typename T&amp;gt; struct BinNode{ BinNodePosi(T) parent,lChild,rChild;// 父亲 孩子 T data; int heigt;int size(); //高度 规模 BinNodePosi(T) insertAsLC(T const &amp;amp;);//左孩子插入结点 BinNodePosi(T) insertAsRC(T const &amp;amp;);//右孩子插入结点 BinNodePosi(T) succ();//(中序意义下) 当前节点直接后继 template &amp;lt;typename VST&amp;gt; void travlevel (VST &amp;amp;);//层次遍历 template &amp;lt;typename VST&amp;gt; void travPre (VST &amp;amp;);//先序遍历 template &amp;lt;typename VST&amp;gt; void travIn(VST &amp;amp;);//中序遍历 template &amp;lt;typename VST&amp;gt; void travPost(VST &amp;amp;);//后续遍历}插入结点template &amp;lt;typename T&amp;gt; BinNOdePosi(T) BinNode&amp;lt;T&amp;gt;::insertAsLC(T const &amp;amp; e){ return lChild=new BinNode(e,this);}右孩子结点插入相似O(1)size的实现template &amp;lt;typename&amp;gt; int BinNode&amp;lt;T&amp;gt;::size(){ int s=1;// 计入根本身 if(lChild) s+=lChild-&amp;gt;size();//递归计算左子树 if(rChild) s+=rChild-&amp;gt;size(); return s;}时间复杂度O(n)2.树 的模板类实现BinTreetemplate &amp;lt;typename T&amp;gt; class BinTree{protected: int size; //规模 BinNodePosi(T) root; //根节点 virtual int updateHeight(BinNodePosi(T) x)//更新结点x的高度public: int size()const{ return size; } bool empty()const { return !root; }//判空 BinNodePosi(T) root() const{ return root; }//树根 /* 还有一群遍历算法*/}高度更新高度： 一结点到其叶子结点的最大深度（空树的高度为-1）" }, { "title": "Kmp算法", "url": "/posts/KMP%E7%AE%97%E6%B3%95/", "categories": "", "tags": "", "date": "2022-04-15 00:00:00 +0000", "snippet": "KMP算法浅聊一下对KMP算法的理解吧。自认为KMP算法还是有些难理解的。原本的暴力破解字符串匹配问题上，每发生一次不匹配情况都需要子串（t）回溯到第一个位置，然后再和主串（s）的下一位进行匹配。这种模式下，对前面已经匹配过的字符又进行了重复运算，回溯的步骤太多，造成了大量的资源浪费。这种算法下的时间复杂度 达到了O（m*n）。 最长相等前后缀在讲KMP算法前，需要引入一个前后缀概念如abcab，最长前后缀是ab，长度为2再如a b c d e a b c 最长前后缀是abc，长度为3相信这个概念通过这两个例子还是很好理解的。 KMP算法原理在有了最长相等前后缀这个概念之后，我们就可以聊一聊KMP算法是如何实现的了对于已经进行匹配的字符串而言，最长前后缀是abc（蓝色），长度为3.根据KMP算法原理，我们需要将子串向后移动再进行比较，移动结果就是将子串的最长相等前缀移动到主串的最长相等后缀的位置上。这基本上就是KMP算法的原理。移位的实现1.next[i]数组的含义next[i]的值表示下标为i的字符前的字符串最长相等前后缀的长度。同时next[i]也是在i处不匹配后，子串应该回溯到的位置，也就是t[next[i]]对于原例来讲，其next[]数组的值如下 a b c d a b c c g m next[0] next[1] next[2] next[3] next[4] next[5] next[6] next[7] next[8] next[9] -1 0 0 0 0 1 2 3 0 0 2.next[i]的代码实现及图解2.1. 代码实现typedef struct{ char data[MaxSize]; int length; //串长} SqString; //串的结构体定义void GetNext(SqString t,int next[i]){ int j=0,k=-1; int next[0]=-1; //初始化 while(j&amp;lt;t.length-1)// 每一次对next[]赋值都是发生在j++之后 if(k==-1||t.data[j]==t.data[k]){ k++,j++; next[j]=k; } //如果在k位置和j位置上的字符串相匹配，则红色区域，也就是前后缀长度+1 else{ k=next[k]; }/*这一步感觉是有些难的。 我们已知next[k]代表的是在k位置前的最长前后缀的长度 那么如果出现字符串不匹配的情况，我们就需要在红色部分 也就是原有的最长前缀里再寻找相等前后缀 那么t.data[k]就是原有的红色部分里继续开始寻找前后缀 的位置*/}2.2.图解这里就直接引用网上的图解了，感觉还是比较清晰的。KMP 算法实现int KMPIndex(SqString s,SqString t) { int next[MaxSize],i=0,j=0; GetNext(t,next); while (i&amp;lt;s.length &amp;amp;&amp;amp; j&amp;lt;t.length) { if (j==-1 || s.data[i]==t.data[j]) { i++;j++; //i,j各增1 } else j=next[j]; //主串i位置不变，子串以最长前后缀长度为 回溯长度 } if (j&amp;gt;=t.length) return(i-t.length); //返回匹配模式串的首字符下标 else return(-1); //返回不匹配标志}" }, { "title": "你好世界", "url": "/posts/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/", "categories": "", "tags": "", "date": "2022-04-14 00:00:00 +0000", "snippet": "你好世界#include &amp;lt;iostream&amp;gt;int main(){ std::cout&amp;lt;&amp;lt;&quot;hello world&quot;; return 0;}" } ]
