<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>爬坑的jjkls</title><subtitle>这是通过Chirpy主题配置而成的</subtitle> <updated>2022-04-24T04:39:48+00:00</updated> <author> <name>your_full_name</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2022 your_full_name </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>无语</title><link href="/posts/%E6%97%A0%E8%AF%AD/" rel="alternate" type="text/html" title="无语" /><published>2022-04-24T00:00:00+00:00</published> <updated>2022-04-24T00:00:00+00:00</updated> <id>/posts/%E6%97%A0%E8%AF%AD/</id> <content src="/posts/%E6%97%A0%E8%AF%AD/" /> <author> <name>your_full_name</name> </author> <summary> …感觉连C++语言还不怎么会呢，还要挣扎着学数据结构 猪脑过载 </summary> </entry> <entry><title>树的学习笔记</title><link href="/posts/%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="树的学习笔记" /><published>2022-04-21T00:00:00+00:00</published> <updated>2022-04-21T04:19:48+00:00</updated> <id>/posts/%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id> <content src="/posts/%E6%A0%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" /> <author> <name>your_full_name</name> </author> <summary> 二叉树 基本概念 1.记录根节点的高度为0，那么一个满二叉树的结点个数为2^(h+1)-1 利用等比求和…..，最少为h+1 二叉树的实现 1.基本结点BinNode 模板类 #define BinNodePosi(T) BinNode&amp;lt;T&amp;gt;* //结点位置 template &amp;lt;typename T&amp;gt; struct BinNode{ BinNodePosi(T) parent,lChild,rChild;// 父亲 孩子 T data; int heigt;int size(); //高度 规模 BinNodePosi(T) insertAsLC(T const &amp;amp;);//左孩子插入结点 BinNodePosi(T) insertAsRC(T const &amp;amp;);//右孩子插入结点 BinN... </summary> </entry> <entry><title>Kmp算法</title><link href="/posts/KMP%E7%AE%97%E6%B3%95/" rel="alternate" type="text/html" title="Kmp算法" /><published>2022-04-15T00:00:00+00:00</published> <updated>2022-04-15T00:00:00+00:00</updated> <id>/posts/KMP%E7%AE%97%E6%B3%95/</id> <content src="/posts/KMP%E7%AE%97%E6%B3%95/" /> <author> <name>your_full_name</name> </author> <summary> KMP算法 浅聊一下对KMP算法的理解吧。自认为KMP算法还是有些难理解的。 原本的暴力破解字符串匹配问题上，每发生一次不匹配情况都需要子串（t）回溯到第一个位置，然后再和主串（s）的下一位进行匹配。这种模式下，对前面已经匹配过的字符又进行了重复运算，回溯的步骤太多，造成了大量的资源浪费。这种算法下的时间复杂度 达到了O（m*n）。 最长相等前后缀 在讲KMP算法前，需要引入一个前后缀概念 如abcab，最长前后缀是ab，长度为2 再如a b c d e a b c 最长前后缀是abc，长度为3 相信这个概念通过这两个例子还是很好理解的。 KMP算法原理 在有了最长相等前后缀这个概念之后，我们就可以聊一聊KMP算法是如何实现的了 对于已经进行匹配的字符串而言，最长前后缀是abc（蓝色），长度为3. 根据KMP算法原理，我们需要将子串向后移... </summary> </entry> <entry><title>你好世界</title><link href="/posts/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/" rel="alternate" type="text/html" title="你好世界" /><published>2022-04-14T00:00:00+00:00</published> <updated>2022-04-14T11:57:54+00:00</updated> <id>/posts/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/</id> <content src="/posts/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/" /> <author> <name>your_full_name</name> </author> <summary> 你好世界 #include &amp;lt;iostream&amp;gt; int main(){ std::cout&amp;lt;&amp;lt;"hello world"; return 0; } </summary> </entry> </feed>
